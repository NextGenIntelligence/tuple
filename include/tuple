#pragma once

#include <type_traits>
#include <stddef.h>
#include <utility>

// allow the user to define an annotation to apply to these functions
// by default, it attempts to be constexpr
#ifndef __TUPLE_ANNOTATION
#  if __cplusplus <= 201103L
#    define __TUPLE_ANNOTATION
#  else
#    define __TUPLE_ANNOTATION constexpr
#  endif
#  define __TUPLE_ANNOTATION_NEEDS_UNDEF
#endif

// allow the user to define a namespace for these functions
#ifndef __TUPLE_NAMESPACE
#define __TUPLE_NAMESPACE std
#endif


namespace __TUPLE_NAMESPACE
{


template<class... Types> class tuple;


} // end namespace


// specializations of stuff in std come before their use
namespace std
{


template<size_t, class> struct tuple_element;


template<size_t i>
struct tuple_element<i, __TUPLE_NAMESPACE::tuple<>> {};


template<class Type1, class... Types>
struct tuple_element<0, __TUPLE_NAMESPACE::tuple<Type1,Types...>>
{
  using type = Type1;
};


template<size_t i, class Type1, class... Types>
struct tuple_element<i, __TUPLE_NAMESPACE::tuple<Type1,Types...>>
{
  using type = typename tuple_element<i - 1, __TUPLE_NAMESPACE::tuple<Types...>>::type;
};


template<size_t i, class... Types>
using tuple_element_t = typename tuple_element<i,Types...>::type;


template<class> struct tuple_size;


template<class... Types>
struct tuple_size<__TUPLE_NAMESPACE::tuple<Types...>>
  : std::integral_constant<size_t, sizeof...(Types)>
{};


} // end std


namespace __TUPLE_NAMESPACE
{


template<class Type1, class... Types>
class tuple<Type1,Types...> : private tuple<Types...>
{
  private:
    using super_t = tuple<Types...>;

  public:
    __TUPLE_ANNOTATION
    tuple() : super_t(), val_() {}


    __TUPLE_ANNOTATION
    explicit tuple(const tuple& other)
      : super_t(other), val_(other.val_)
    {}


    __TUPLE_ANNOTATION
    explicit tuple(tuple&& other)
      : super_t(std::move(other)), val_(std::move(other.val_))
    {}


    __TUPLE_ANNOTATION
    explicit tuple(const Type1& arg1, const Types&... args)
      : super_t(args...), val_(arg1)
    {}


    template<class UType1, class... UTypes>
    __TUPLE_ANNOTATION
    explicit tuple(UType1&& arg1, UTypes&&... args)
      : super_t(std::forward<UTypes...>(args)...), val_(std::forward<UType1>(arg1))
    {}


    // XXX TODO copy from pair


    __TUPLE_ANNOTATION
    tuple& operator=(const tuple& other)
    {
      other.val_ = other.val_;
      return super_t::operator=(other);
    }


    __TUPLE_ANNOTATION
    tuple& operator=(tuple&& other)
    {
      other.val_ = std::move(other.val_);
      return super_t::operator=(std::move(other));
    }


    template<class... UTypes>
    __TUPLE_ANNOTATION
    tuple& operator=(const tuple<UTypes...>& other)
    {
      other.val_ = std::get<0>(other);
      return super_t::operator=(other);
    }


    template<class... UTypes>
    __TUPLE_ANNOTATION
    tuple& operator=(tuple<UTypes...>&& other)
    {
      other.val_ = std::move(std::get<0>(std::move(other)));
      return super_t::operator=(std::move(other));
    }

    // XXX TODO assign from pair

    __TUPLE_ANNOTATION
    void swap(tuple& other)
    {
      using std::swap;

      swap(val_, other.val_);

      super_t::swap(other);
    }

  private:
    Type1 val_;


    // mutable get
    template<size_t i>
    __TUPLE_ANNOTATION
    typename std::tuple_element<i, tuple>::type&
    get_impl(std::true_type)
    {
      return val_;
    }

    template<size_t i>
    __TUPLE_ANNOTATION
    typename std::tuple_element<i,tuple>::type&
    get_impl(std::false_type)
    {
      return super_t::template get<i-1>();
    }


    // const get
    template<size_t i>
    __TUPLE_ANNOTATION
    const typename std::tuple_element<i, tuple>::type&
    get_impl(std::true_type) const
    {
      return val_;
    }

    template<size_t i>
    __TUPLE_ANNOTATION
    const typename std::tuple_element<i,tuple>::type&
    get_impl(std::false_type) const
    {
      return super_t::template get<i-1>();
    }


    // move get
    template<size_t i>
    __TUPLE_ANNOTATION
    typename std::tuple_element<i, tuple>::type&&
    get_impl(std::true_type) &&
    {
      return std::move(val_);
    }

    template<size_t i>
    __TUPLE_ANNOTATION
    typename std::tuple_element<i,tuple>::type&&
    get_impl(std::false_type) &&
    {
      return std::move(static_cast<super_t&&>(*this).template get<i-1>());
    }

  protected:
    template<size_t i>
    __TUPLE_ANNOTATION
    typename std::tuple_element<i, tuple>::type&
    get()
    {
      return get_impl<i>(std::integral_constant<bool, i == 0>());
    }


    template<size_t i>
    __TUPLE_ANNOTATION
    const typename std::tuple_element<i, tuple>::type&
    get() const
    {
      return get_impl<i>(std::integral_constant<bool, i == 0>());
    }


    template<size_t i>
    __TUPLE_ANNOTATION
    typename std::tuple_element<i, tuple>::type&&
    get() &&
    {
      return std::move(std::move(*this).get_impl<i>(std::integral_constant<bool, i == 0>()));
    }


  public:
    template<size_t i, class... UTypes>
    friend __TUPLE_ANNOTATION
    typename std::tuple_element<i, __TUPLE_NAMESPACE::tuple<UTypes...>>::type &
    std::get(__TUPLE_NAMESPACE::tuple<UTypes...>& t);


    template<size_t i, class... UTypes>
    friend __TUPLE_ANNOTATION
    const typename std::tuple_element<i, __TUPLE_NAMESPACE::tuple<UTypes...>>::type &
    std::get(const __TUPLE_NAMESPACE::tuple<UTypes...>& t);


    template<size_t i, class... UTypes>
    friend __TUPLE_ANNOTATION
    typename std::tuple_element<i, __TUPLE_NAMESPACE::tuple<UTypes...>>::type &&
    std::get(__TUPLE_NAMESPACE::tuple<UTypes...>&& t);
};


template<> class tuple<> {};


template<class... Types>
__TUPLE_ANNOTATION
void swap(__TUPLE_NAMESPACE::tuple<Types...>& lhs, __TUPLE_NAMESPACE::tuple<Types...>& rhs)
{
  lhs.swap(rhs);
}


template<class... Types>
__TUPLE_ANNOTATION
tuple<typename std::decay<Types>::type...> make_tuple(Types&&... args)
{
  return tuple<typename std::decay<Types>::type...>(std::forward<Types>(args)...);
}


template<class... Types>
__TUPLE_ANNOTATION
tuple<Types&...> tie(Types&... args)
{
  return tuple<Types&...>(args...);
}


} // end namespace


// implement std::get()
namespace std
{


template<size_t i, class... UTypes>
__TUPLE_ANNOTATION
typename std::tuple_element<i, __TUPLE_NAMESPACE::tuple<UTypes...>>::type &
  get(__TUPLE_NAMESPACE::tuple<UTypes...>& t)
{
  return t.template get<i>();
}


template<size_t i, class... UTypes>
__TUPLE_ANNOTATION
const typename std::tuple_element<i, __TUPLE_NAMESPACE::tuple<UTypes...>>::type &
  get(const __TUPLE_NAMESPACE::tuple<UTypes...>& t)
{
  return t.template get<i>();
}


template<size_t i, class... UTypes>
__TUPLE_ANNOTATION
typename std::tuple_element<i, __TUPLE_NAMESPACE::tuple<UTypes...>>::type &&
  get(__TUPLE_NAMESPACE::tuple<UTypes...>&& t)
{
  return std::move(std::move(t).template get<i>());
}


} // end std


#ifdef __TUPLE_ANNOTATION_NEEDS_UNDEF
#undef __TUPLE_ANNOTATION
#undef __TUPLE_ANNOTATION_NEEDS_UNDEF
#endif

