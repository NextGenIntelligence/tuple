#pragma once

#include <type_traits>
#include <stddef.h>
#include <utility>

// allow the user to define an annotation to apply to these functions
// by default, it attempts to be constexpr
#ifndef __TUPLE_ANNOTATION
#  if __cplusplus <= 201103L
#    define __TUPLE_ANNOTATION
#  else
#    define __TUPLE_ANNOTATION constexpr
#  endif
#  define __TUPLE_ANNOTATION_NEEDS_UNDEF
#endif

// allow the user to define a namespace for these functions
#ifndef __TUPLE_NAMESPACE
#define __TUPLE_NAMESPACE std
#endif


namespace __TUPLE_NAMESPACE
{


template<class... Types> class tuple;


} // end namespace


// specializations of stuff in std come before their use
namespace std
{


template<size_t, class> struct tuple_element;


template<size_t i>
struct tuple_element<i, __TUPLE_NAMESPACE::tuple<>> {};


template<class Type1, class... Types>
struct tuple_element<0, __TUPLE_NAMESPACE::tuple<Type1,Types...>>
{
  using type = Type1;
};


template<size_t i, class Type1, class... Types>
struct tuple_element<i, __TUPLE_NAMESPACE::tuple<Type1,Types...>>
{
  using type = typename tuple_element<i - 1, __TUPLE_NAMESPACE::tuple<Types...>>::type;
};


template<size_t i, class... Types>
using tuple_element_t = typename tuple_element<i,Types...>::type;


template<class> struct tuple_size;


template<class... Types>
struct tuple_size<__TUPLE_NAMESPACE::tuple<Types...>>
  : std::integral_constant<size_t, sizeof...(Types)>
{};


} // end std


namespace __TUPLE_NAMESPACE
{


template<class Type1, class... Types>
class tuple<Type1,Types...>
{
  public:
    __TUPLE_ANNOTATION
    tuple() : head_(), tail_() {}


    __TUPLE_ANNOTATION
    explicit tuple(const Type1& arg1, const Types&... args)
      : head_(arg1), tail_(args...)
    {}


    template<class UType1, class... UTypes>
    __TUPLE_ANNOTATION
    explicit tuple(UType1&& arg1, UTypes&&... args)
      : head_(std::forward<UType1>(arg1)),
        tail_(std::forward<UTypes>(args)...)
    {}


    template<class UType1, class... UTypes>
    __TUPLE_ANNOTATION
    tuple(const tuple<UType1,UTypes...>& other)
      : head_(other.head_),
        tail_(other.tail_)
    {}


    template<class UType1, class... UTypes>
    __TUPLE_ANNOTATION
    tuple(tuple<UType1,UTypes...>&& other)
      : head_(std::move(other.head_)),
        tail_(std::move(other.tail_))
    {}


    __TUPLE_ANNOTATION
    tuple(const tuple& other)
      : head_(other.head_),
        tail_(other.tail_)
    {}


    __TUPLE_ANNOTATION
    tuple(tuple&& other)
      : head_(std::move(other.head_)),
        tail_(std::move(other.tail_))
    {}


    // XXX TODO copy from pair


    __TUPLE_ANNOTATION
    tuple& operator=(const tuple& other)
    {
      other.head_ = other.head_;
      other.tail_ = other.tail_;
      return *this;
    }


    __TUPLE_ANNOTATION
    tuple& operator=(tuple&& other)
    {
      other.head_ = std::move(other.head_);
      other.tail_ = std::move(other.tail_);
      return *this;
    }


    template<class... UTypes>
    __TUPLE_ANNOTATION
    tuple& operator=(const tuple<UTypes...>& other)
    {
      other.head_ = other.head_;
      other.tail_ = other.tail_;
      return *this;
    }


    template<class... UTypes>
    __TUPLE_ANNOTATION
    tuple& operator=(tuple<UTypes...>&& other)
    {
      other.head_ = std::move(other.head_);
      other.tail_ = std::move(other.tail_);
      return *this;
    }

    // XXX TODO assign from pair

    __TUPLE_ANNOTATION
    void swap(tuple& other)
    {
      using std::swap;

      swap(head_, other.head_);
      tail_.swap(other.tail_);
    }

  private:
    Type1 head_;
    tuple<Types...> tail_;


    template<class... UTypes>
    friend class tuple;


    // mutable get
    template<size_t i>
    __TUPLE_ANNOTATION
    typename std::tuple_element<i, tuple>::type&
    get_impl(std::true_type)
    {
      return head_;
    }

    template<size_t i>
    __TUPLE_ANNOTATION
    typename std::tuple_element<i,tuple>::type&
    get_impl(std::false_type)
    {
      return tail_.template get<i-1>();
    }


    // const get
    template<size_t i>
    __TUPLE_ANNOTATION
    const typename std::tuple_element<i, tuple>::type&
    get_impl(std::true_type) const
    {
      return head_;
    }

    template<size_t i>
    __TUPLE_ANNOTATION
    const typename std::tuple_element<i,tuple>::type&
    get_impl(std::false_type) const
    {
      return tail_.template get<i-1>();
    }


    // move get
    template<size_t i>
    __TUPLE_ANNOTATION
    typename std::tuple_element<i, tuple>::type&&
    get_impl(std::true_type) &&
    {
      return std::move(head_);
    }

    template<size_t i>
    __TUPLE_ANNOTATION
    typename std::tuple_element<i,tuple>::type&&
    get_impl(std::false_type) &&
    {
      return std::move(std::move(tail_).template get<i-1>());
    }

  protected:
    template<size_t i>
    __TUPLE_ANNOTATION
    typename std::tuple_element<i, tuple>::type&
    get()
    {
      return get_impl<i>(std::integral_constant<bool, i == 0>());
    }


    template<size_t i>
    __TUPLE_ANNOTATION
    const typename std::tuple_element<i, tuple>::type&
    get() const
    {
      return get_impl<i>(std::integral_constant<bool, i == 0>());
    }


    template<size_t i>
    __TUPLE_ANNOTATION
    typename std::tuple_element<i, tuple>::type&&
    get() &&
    {
      return std::move(std::move(*this).get_impl<i>(std::integral_constant<bool, i == 0>()));
    }


  public:
    template<size_t i, class... UTypes>
    friend __TUPLE_ANNOTATION
    typename std::tuple_element<i, __TUPLE_NAMESPACE::tuple<UTypes...>>::type &
    std::get(__TUPLE_NAMESPACE::tuple<UTypes...>& t);


    template<size_t i, class... UTypes>
    friend __TUPLE_ANNOTATION
    const typename std::tuple_element<i, __TUPLE_NAMESPACE::tuple<UTypes...>>::type &
    std::get(const __TUPLE_NAMESPACE::tuple<UTypes...>& t);


    template<size_t i, class... UTypes>
    friend __TUPLE_ANNOTATION
    typename std::tuple_element<i, __TUPLE_NAMESPACE::tuple<UTypes...>>::type &&
    std::get(__TUPLE_NAMESPACE::tuple<UTypes...>&& t);
};


template<> class tuple<> {};


template<class... Types>
__TUPLE_ANNOTATION
void swap(__TUPLE_NAMESPACE::tuple<Types...>& lhs, __TUPLE_NAMESPACE::tuple<Types...>& rhs)
{
  lhs.swap(rhs);
}


template<class... Types>
__TUPLE_ANNOTATION
tuple<typename std::decay<Types>::type...> make_tuple(Types&&... args)
{
  return tuple<typename std::decay<Types>::type...>(std::forward<Types>(args)...);
}


template<class... Types>
__TUPLE_ANNOTATION
tuple<Types&...> tie(Types&... args)
{
  return tuple<Types&...>(args...);
}


} // end namespace


// implement std::get()
namespace std
{


template<size_t i, class... UTypes>
__TUPLE_ANNOTATION
typename std::tuple_element<i, __TUPLE_NAMESPACE::tuple<UTypes...>>::type &
  get(__TUPLE_NAMESPACE::tuple<UTypes...>& t)
{
  return t.template get<i>();
}


template<size_t i, class... UTypes>
__TUPLE_ANNOTATION
const typename std::tuple_element<i, __TUPLE_NAMESPACE::tuple<UTypes...>>::type &
  get(const __TUPLE_NAMESPACE::tuple<UTypes...>& t)
{
  return t.template get<i>();
}


template<size_t i, class... UTypes>
__TUPLE_ANNOTATION
typename std::tuple_element<i, __TUPLE_NAMESPACE::tuple<UTypes...>>::type &&
  get(__TUPLE_NAMESPACE::tuple<UTypes...>&& t)
{
  return std::move(t.template get<i>());
}


} // end std


#ifdef __TUPLE_ANNOTATION_NEEDS_UNDEF
#undef __TUPLE_ANNOTATION
#undef __TUPLE_ANNOTATION_NEEDS_UNDEF
#endif

